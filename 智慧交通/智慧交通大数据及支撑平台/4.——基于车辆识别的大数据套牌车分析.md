# 基于车辆识别的大数据套牌车分析

## 1.1 概述

套牌车是指那些未按照正常程序到交通管理部门领取和办理相关手续而悬挂非法伪造车牌在道路上行驶的车辆。套牌车是一种侵犯真正车主利益到交通违法行为。

现有套牌车防范方法主要有如下几种：

Ø 基于视频和图像分析到号牌识别技术

Ø 防套牌功能车牌

Ø 加装无滤芯片等智能车牌技术

Ø 基于电子标签等车牌识别技术

Ø 机动车号牌专用固封装置等

目前随着城市视频监控系统等大范围建设和普及，基于网格化等号牌识别系统由于保存了通过监测点的每一辆机动车的车牌信息，在进行城市套牌车分析方面具有独特的优势，传统的套牌车识别算法有如下主要步骤：

Ø 号牌识别系统采集到车辆经过各监控点的车牌号码，时间以及监控点ID等数据

Ø 通过数据化比对，将各监控点的车牌数据进行行关联，找出车牌在监控点出现的时间

Ø 如果在预设的最短时间内在不同监控点出现同样的车牌，则判定为套牌车

在该算法中使用预设的最小时间窗口来判定套牌车，但是在真实的城市道路交通中存在交通流高峰，交通流低峰等现象，监控点之间的实际旅行时间不是固定的，因此使用固定的时间窗口会影响套牌车的判断精度。其次该算法基于关系数据库，其扩展性存在一定的局限性，即使增加CPU、内存等硬件性能，不适合处理交通流大数据，最终导致性能瓶颈问题。

鉴于上述问题，提出了基于流式计算的套牌车分析模型，该计算模型主要解决如下难题：（1）实时性：套牌车甄别出的结果数据具有时效性，套牌车出现后应该在较短的时间内甄别出来，才能协助交管部门进行交通执法。（2）准确性：套牌车甄别的正确率越高，交管部门打击套牌车现象力度越大，交通规范越好。

前端车辆识别视频设备多达几千台，在高峰期的采样频率为1s/条，1h就会产生上千万条数据，套牌车的计算是根据其时空矛盾来判定的，因此不仅仅是对实时数据的计算，部分历史数据以及基础数据也要经过计算，参与计算的数据量大，在这个背景下提出了基于路段阀值表带套牌车甄别流式计算模型，针对历史交通数据设计了时间滑动窗口，实现了对交通数据流中出现的套牌车实时自动甄别.

## 1.2 流式计算Storm简介

Storm是一款支持分布式、开源、实时、主从式大数据流式计算系统，由一个主控节点和多个工作节点构成，Storm做实时计算时，首先创建一个拓扑（topology），计算逻辑被封装在一个拓扑对象中，一个拓扑对象是一个由多个Spout和Bolt节点连接成的有向图，拓扑中的每一个节点包含处理逻辑，节点之间的连接显示数据应该如何在节点进行传输。

对比Hadoop的批处理，Storm是个实时的、分布式以及具备高容错的计算系统，同Hadoop一样Strom也可以处理大批量的数据，然而Strom在保证高可靠的前提下还可以让处理进行的更加实时，也就是说所有的信息都会被处理。Storm同样还具备容错和分布式计算这些特性，这就让Storm可以扩展到不同的机器上进行大批量的数据处理。

Storm集群主要由一个主节点（Nimbus后台程序）和一群工作节点（worker node）Supervisor的节点组成，通过 Zookeeper进行协调。Nimbus类似Hadoop里面的JobTracker。Nimbus负责在集群里面分发代码，分配计算任务给机器，并且监控状态。

每一个工作节点上面运行一个叫做Supervisor的节点。Supervisor会监听分配给它那台机器的工作，根据需要启动/关闭工作进程。每一个工作进程执行一个topology的一个子集；一个运行的topology由运行在很多机器上的很多工作进程组成。

Ø Nimbus主节点

 主节点通常运行一个后台程序 —— Nimbus，用于响应分布在集群中的节点，分配任务和监测故障。这个很类似于Hadoop中的Job Tracker。

Ø Supervisor工作节点

工作节点同样会运行一个后台程序 —— Supervisor，用于收听工作指派并基于要求运行工作进程。每个工作节点都是topology中一个子集的实现。而Nimbus和Supervisor之间的协调则通过Zookeeper系统或者集群。

Ø Zookeeper

Zookeeper是完成Supervisor和Nimbus之间协调的服务。而应用程序实现实时的逻辑则被封装进Storm中的“topology”。topology则是一组由Spouts（数据源）和Bolts（数据操作）通过Stream Groupings进行连接的图。下面对出现的术语进行更深刻的解析。

Ø Worker 

运行具体处理组件逻辑的进程。

Ø Task

worker中每一个spout/bolt的线程称为一个task.

Ø Topology（拓扑）

 storm中运行的一个实时应用程序，因为各个组件间的消息流动形成逻辑上的一个拓扑结构。一个topology是spouts和bolts组成的图，通过stream groupings将图中的spouts和bolts连接起来，如下图：

![image-20210727154738629](https://gitee.com/er-huomeng/l-img/raw/master/img/image-20210727154738629.png)

**图**6.85 **storm拓扑图**

 一个topology会一直运行直到你手动kill掉，Storm自动重新分配执行失败的任务，并且Storm可以保证你不会有数据丢失（如果开启了高可靠性的话）。如果一些机器意外停机它上面的所有任务会被转移到其他机器上。

Ø Spout

消息源spout是Storm里面一个topology里面的消息生产者。简而言之，Spout从来源处读取数据并放入topology。Spout分成可靠和不可靠两种；当Storm接收失败时，可靠的Spout会对tuple（元组，数据项组成的列表）进行重发；而不可靠的Spout不会考虑接收成功与否只发射一次。

Ø Bolt

Topology中所有的处理都由Bolt完成。即所有的消息处理逻辑被封装在bolts里面。Bolt可以完成任何事，比如：连接的过滤、聚合、访问文件/数据库、等等。

Bolt从Spout中接收数据并进行处理，如果遇到复杂流的处理也可能将tuple发送给另一个Bolt进行处理。即需要经过很多blots。

Ø Tuple

一次消息传递的基本单元。本来应该是一个key.value的map，但是由于各个组件间传递的tuple的字段名称已经事先定义好，所以tuple中只要按序填入各个value就行了，所以就是一个value list.

Ø Stream

 源源不断传递的tuple就组成了stream。消息流stream是storm里的关键抽象。一个消息流是一个没有边界的tuple序列，而这些tuple序列会以一种分布式的方式并行地创建和处理。通过对stream中tuple序列中每个字段命名来定义stream。在默认的情况下，tuple的字段类型可以是：integer，long，short， byte，string，double，float，boolean和byte array。你也可以自定义类型（只要实现相应的序列化器）。

Strom开源后在互联网领域和金融银行领域的实时监控场景中得到了充分的应用，例如淘宝的虫洞系统以Strom实时流处理为引擎，进行个性化推荐、热门话题统计等；在银行中处理系统内部各个子系统实时信息，实现对全局的监控和各种优化；除此之外在分布式远程调用、在线机器学习、数据抽取转化和加载等领域也得到了广泛的应用。

## 1.3 框架

本系统在Storm环境下通过利用套牌车的时空特性进行计算，合理组织利用业务数据，对实时到达的车牌识别数据进行分析，根据当前车辆的地理位置（监测点）找出此车牌车辆过去一段时间内经过的所有监测点，结合基础路段信息构建路段并计算出车辆经过这些路段的旅行时间，利用基础路段阀值表中的路段阀值判断车辆在所经过路段上是否出现了套牌。架构设计图如下图，数据的输入分为两类：经过消息中间件传输的实时数据和数据库中的基础数据。流式数据是前端设备实时发送的车牌识别数据，通过消息中间件实现事件触发推送到系统；基础数据是通过数据库读取接口读取到处理系统的，为实现基础数据更新后的业务连续性，每隔一段时间对加载的基础数据进行定时更新。运行时环境用于维护数据结构和完成数据处理，包括对实时数据的接入，对具有时空特性的流式数据以滑动时间窗口形式进行维护，基础数据在内存中hash结构，对流式数据的划分策略、计算并行度的配置以及监控和日志等基础功能。数据的输出只要对计算的套牌嫌疑车直接进行实时布控以帮助交管部门进行执法以及将计算结果写到数据库用于长期存储。

![image-20210727154801613](https://gitee.com/er-huomeng/l-img/raw/master/img/image-20210727154801613.png)

### 1.3.1 技术实现

通过前端卡口摄像机识别的车牌号、位置信息、利用“时间差”判定，检测出涉嫌套牌车辆的方法，既基于同一车辆在不可能时间内出现在两个地方的原理，分析各监控点的车牌信息，实现套牌车的自动检测。

#### 1.3.1.1. 监控点的选取

只有选取合适的监控点，才能最大程度减少套牌车漏分析，因此选取监控点应符合最少监控点、最大车流量大原则，一般优先选取以下监控点：

Ø 城市主干道路，尤其是繁华地段

Ø 大型停车场、车站、火车站等繁忙路段和交叉口

#### 1.3.1.2 数据定义

Ø 实时数据前端高清摄像头产生的车辆识别数据，每秒会有2000多条。系统对接收数据流中的每一条车牌识别数据都会进行实时计算。

Ø 业务数据套牌阀值表，该表中存储着城市道路的路段旅行时间，即此路段的套牌阀值。

Ø 历史数据历史数据存储的是当前接入的实时数据。历史数据的存储时间和大小是根据业务数据中最大的套牌阀值决定的，假设套牌阀值表中存储的旅行时间阀值最大为1h，即从该路段上的上游监测点出发行驶到下游监测点的最长时间为1h。假设当前到达的实时数据是某辆车在该路段的下游监测点拍摄到的，判定这辆车在该路段是否出现了套牌现象，则需要这辆车在该路段上游监测点被拍摄的车辆识别数据，结合上下游监测点的时空属性进行计算，因此在历史数据中应该存有这条车辆识别数据。所以历史数据的时间长度不能小于业务数据中最大的套牌阀值。

### 1.3.2 实时数据

组件spout是Storm整个框架中的数据源，计算套牌车的数据源Spout组件以队列连接的形式从消息中间接收车牌识别数据，由于识别数据是一个由拍摄的照片、时间和车身颜色等多个属性整合成的数据结构，蕴含的信息比较庞杂，包括比如车身颜色等对套牌车计算无用的信息，这种冗余信息需要剔除以减少对内存对消耗，最后将识别数据中的车牌号、时间、监控点Id等属性封装成一个Tuple元祖，Spout通过跟踪每一个元组树来确保每一个元组被可靠的处理，成功处理调用ack方法，失败处理调用fail方法，确保数据处理的完整性。

Tuple元组中属性字段说明：

**表**6.85**Tuple元组中属性字段说明**

| **字段名**   | **字段类型** | **字段说明** |
| ------------ | ------------ | ------------ |
| DeviceId     | String       | 监控点ID     |
| PlateNumber  | String       | 车牌号       |
| VehicleColor | String       | 车辆颜色     |
| VihicleType  | String       | 车辆类型     |
| RecordTime   | String       | 记录时间     |

#### 1.3.2.1 业务数据

用两个哈希表（HashMap）进行存储，一个哈希表以路段上游监测点作为键值Key，Value为一个由此键值Key作为上游监测点的所有路段的下游监测点组成的集合；另一个哈希表以路段下游监测点作为Key，Value为一个由此键值作为下游监测点的所有路段的上游监测点组成的集合。

#### 1.3.2.2 历史数据

假设所用业务数据中最大的套牌阀值值为1h，因此需要维护历史数据的时间长度为1h，将最近1h活跃的数据对象存储在内存中。需要维护一种不但能够对当前识别数据保存1h而且在时间过后对数据进行删除的数据结构。RotatingMap是Storm用来保存最近活跃对象和可以自动删除过期对象的数据结构，是由多个HashMap组成的一个LinkedList集合。

### 1.3.3 基于Strom流式计算的数据分析

拓扑逻辑如下图所示，主要由三部分组成：数据源（Spout），套牌计算（T_bolt）和数据存储（DB_bolt）。在作业topology中，数据源Spout为作业从外部的数据源获取车牌识别数据并剔除无效数据项，封装成元组（Tuple），向计算组件不断的emit（发射）Tuple组成Stream。套牌计算是分布式并行计算，因此有多个计算组件Bolt独立存在，它们的计算互不干扰，每个Bolt都会接收上游送达的stream作为数据输入，合理组织基础数据和接收的数据，进而根据时空矛盾规则进行套牌车的计算，将计算出的套牌信息封装成Tuple发射到下一个Bolt，作为DB_Bolt的数据输入。DB_Bol接受所有进行套牌计算组件的计算结果，把接收的数据存储到数据库中。

![image-20210727154952540](https://gitee.com/er-huomeng/l-img/raw/master/img/image-20210727154952540.png)

**图**6.87**拓扑逻辑****图**

#### 1.3.3.1 数据划分

作业Topology中Spout按Tuple中指定域的值.车牌号码进行分组来进行数据划分，向下游目标组件Bolt发送Tuple，即同一车牌的识别数据发送到同一个计算组件中，如下图所示，这样设计能够确保具有相同车牌号的Tuple被发送到同一个Bolt，即同一个车牌号的识别数据会一直被确定的Bolt处理而不会分散到其他的Bolt上，保证了同一车牌号的计算中不会出现数据丢失的现象。按车牌号划分的这种数据划分方式使计算水平扩展到多个节点，多个节点同时进行套牌车甄别，实现了分布式计算。

![image-20210727155008022](https://gitee.com/er-huomeng/l-img/raw/master/img/image-20210727155008022.png)

**图**6.88**数据划分****示意图**

#### 1.3.3.2 套牌车计算流程

![image-20210727155026581](https://gitee.com/er-huomeng/l-img/raw/master/img/image-20210727155026581.png)

**图**6.89**套牌车计算流程****图**

套牌车计算程序流程如上图所示，由于Storm中的进程以服务的形式存在，除非人为主动停止集群或者集群故障，这些进程将一直运行下去，所以流程只有开始标记而没有结束标记。具体的处理流程如下：

Ø 对于来到的每一条数据获取其监测点、车牌号以及时间戳，判断路段基础信息表中是否有此监测点，如果没有则废弃此条数据；如果有则进行下一步。

Ø 取出以此监测点作为路段上游监测点的所有路段以及路段阈值，以此监测点Id为Key，所有下游监测点组成的集合作为Value，组成HashMap；取出以此监测点作为路段下游监测点的所有路段及其路段阈值，以此监测点Id为Key，所有上游监测点组成的集合作为Value，组成HashMap。共有两个哈希表。

Ø 找出当前车牌号行驶过的路段。循环遍历以此监测点Id为上游监测点Key的HashMap的Value值，将当前识别数据的车牌和遍历Value所得的一个下游监测点组合成键值Key，获取时间窗口中缓存的信息，用来判断是否有通过这个下游监测点的车辆。

Ø 计算当前车牌车辆所行驶过的路段的旅行时间，并判断旅行时间是否小于套牌阈值，如果是则将此套嫌疑车信息封装为Tuple传递给下一个Bolt。

Ø 将另一个HashMap中的数据按照第三步和第四步做同样的处理。

Ø 将当前交通信息的车牌号和其监测点作为Key，时间戳作为Value存入时间窗口中

Ø 将上一个Bolt传递过来的套牌嫌疑车信息存入数据库并对套牌嫌疑车加以布控。